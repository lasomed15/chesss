<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chess Game with Replay</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: sans-serif;
    background-color: #eee;
  }
  h1 { margin-top: 20px; }
  #chessboard {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 2px solid #333;
    margin-top: 20px;
  }
  .square {
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 36px;
    cursor: pointer;
  }
  .square.black { background-color: #769656; }
  .square.white { background-color: #eeeed2; }
  .selected { border: 3px solid red !important; }
  button { margin-top: 10px; padding: 10px 20px; font-size: 16px; }
</style>
</head>
<body>
<h1>Chess Game</h1>
<div id="chessboard"></div>
<p id="status"></p>
<button id="replayBtn">Replay Game</button>

<script>
const chessboard = document.getElementById('chessboard');
const status = document.getElementById('status');
const replayBtn = document.getElementById('replayBtn');

let board = [
  ['♜','♞','♝','♛','♚','♝','♞','♜'],
  ['♟','♟','♟','♟','♟','♟','♟','♟'],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['♙','♙','♙','♙','♙','♙','♙','♙'],
  ['♖','♘','♗','♕','♔','♗','♘','♖']
];

let turn = 'white';
let selected = null;
let moveHistory = []; // store all moves for replay

function cloneBoard(b){
  return b.map(r=>[...r]);
}

// Utility functions
function isWhite(piece) { return ['♙','♖','♘','♗','♕','♔'].includes(piece); }
function isBlack(piece) { return ['♟','♜','♞','♝','♛','♚'].includes(piece); }
function isEmpty(row, col) { return board[row][col] === ''; }
function inBounds(row, col) { return row >= 0 && row < 8 && col >= 0 && col < 8; }

function drawBoard(highlightSquares=[]) {
  chessboard.innerHTML = '';
  for(let row=0; row<8; row++) {
    for(let col=0; col<8; col++) {
      const square = document.createElement('div');
      square.classList.add('square', (row+col)%2===0?'white':'black');
      square.dataset.row = row;
      square.dataset.col = col;
      square.textContent = board[row][col];

      if(selected && selected.row === row && selected.col === col) square.classList.add('selected');
      if(highlightSquares.some(sq => sq.row===row && sq.col===col)) square.style.border='3px solid yellow';

      chessboard.appendChild(square);
    }
  }
  status.textContent = `${turn.charAt(0).toUpperCase()+turn.slice(1)}'s turn`;
}

// Get legal moves (same as before)
function getLegalMoves(row, col) {
  const piece = board[row][col];
  const moves = [];
  if(piece === '') return moves;
  const color = isWhite(piece)?'white':'black';
  const enemy = color==='white'?isBlack:isWhite;

  if(piece==='♙'){
    if(inBounds(row-1,col) && isEmpty(row-1,col)) moves.push({row:row-1,col});
    if(row===6 && isEmpty(row-1,col) && isEmpty(row-2,col)) moves.push({row:row-2,col});
    if(inBounds(row-1,col-1) && enemy(board[row-1][col-1])) moves.push({row:row-1,col:col-1});
    if(inBounds(row-1,col+1) && enemy(board[row-1][col+1])) moves.push({row:row-1,col:col+1});
  }
  if(piece==='♟'){
    if(inBounds(row+1,col) && isEmpty(row+1,col)) moves.push({row:row+1,col});
    if(row===1 && isEmpty(row+1,col) && isEmpty(row+2,col)) moves.push({row:row+2,col});
    if(inBounds(row+1,col-1) && enemy(board[row+1][col-1])) moves.push({row:row+1,col:col-1});
    if(inBounds(row+1,col+1) && enemy(board[row+1][col+1])) moves.push({row:row+1,col:col+1});
  }

  if(piece==='♘'||piece==='♞'){
    const deltas=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    deltas.forEach(d=>{ const r=row+d[0],c=col+d[1]; if(inBounds(r,c) && (!board[r][c] || enemy(board[r][c]))) moves.push({row:r,col:c}); });
  }

  if(piece==='♖'||piece==='♜'){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    dirs.forEach(d=>{
      let r=row+d[0],c=col+d[1];
      while(inBounds(r,c)&&(isEmpty(r,c)||enemy(board[r][c]))){
        moves.push({row:r,col:c}); if(!isEmpty(r,c)) break; r+=d[0]; c+=d[1];
      }
    });
  }

  if(piece==='♗'||piece==='♝'){
    const dirs=[[1,1],[1,-1],[-1,1],[-1,-1]];
    dirs.forEach(d=>{
      let r=row+d[0],c=col+d[1];
      while(inBounds(r,c)&&(isEmpty(r,c)||enemy(board[r][c]))){
        moves.push({row:r,col:c}); if(!isEmpty(r,c)) break; r+=d[0]; c+=d[1];
      }
    });
  }

  if(piece==='♕'||piece==='♛'){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    dirs.forEach(d=>{
      let r=row+d[0],c=col+d[1];
      while(inBounds(r,c)&&(isEmpty(r,c)||enemy(board[r][c]))){
        moves.push({row:r,col:c}); if(!isEmpty(r,c)) break; r+=d[0]; c+=d[1];
      }
    });
  }

  if(piece==='♔'||piece==='♚'){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    dirs.forEach(d=>{
      const r=row+d[0],c=col+d[1]; if(inBounds(r,c) && (!board[r][c] || enemy(board[r][c]))) moves.push({row:r,col:c});
    });
  }

  return moves;
}

// In check detection
function inCheck(color){
  let kingPos;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    if((color==='white'&&board[r][c]==='♔')||(color==='black'&&board[r][c]==='♚')) kingPos={row:r,col:c};
  }
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const piece=board[r][c];
    if(piece && ((color==='white'&&isBlack(piece))||(color==='black'&&isWhite(piece)))){
      const moves=getLegalMoves(r,c);
      if(moves.some(m=>m.row===kingPos.row&&m.col===kingPos.col)) return true;
    }
  }
  return false;
}

// Checkmate detection
function checkMate(color){
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const piece=board[r][c];
    if(piece && ((color==='white'&&isWhite(piece))||(color==='black'&&isBlack(piece)))){
      const moves=getLegalMoves(r,c);
      for(const m of moves){
        const backup=board[m.row][m.col];
        board[m.row][m.col]=piece;
        board[r][c]='';
        if(!inCheck(color)){board[r][c]=piece; board[m.row][m.col]=backup; return false;}
        board[r][c]=piece; board[m.row][m.col]=backup;
      }
    }
  }
  return true;
}

// Click handling
chessboard.addEventListener('click',(e)=>{
  const square=e.target; if(!square.classList.contains('square')) return;
  const row=parseInt(square.dataset.row);
  const col=parseInt(square.dataset.col);
  const piece=board[row][col];

  if(!selected){
    if(piece && ((turn==='white'&&isWhite(piece))||(turn==='black'&&isBlack(piece)))){
      selected={row,col};
      drawBoard(getLegalMoves(row,col));
    }
  } else {
    const moves=getLegalMoves(selected.row,selected.col);
    if(moves.some(m=>m.row===row && m.col===col)){
      const movingPiece=board[selected.row][selected.col];
      // Save move for replay
      moveHistory.push({from:{row:selected.row,col:selected.col,piece:movingPiece},to:{row,col,piece:board[row][col]},turn});
      board[row][col]=movingPiece;
      board[selected.row][selected.col]='';
      if(movingPiece==='♙' && row===0) board[row][col]='♕';
      if(movingPiece==='♟' && row===7) board[row][col]='♛';
      const enemy=turn==='white'?'black':'white';
      if(inCheck(enemy)){
        if(checkMate(enemy)) alert(`Checkmate! ${turn.charAt(0).toUpperCase()+turn.slice(1)} wins!`);
        else alert(`${enemy.charAt(0).toUpperCase()+enemy.slice(1)} is in check!`);
      }
      turn=enemy;
      selected=null;
      drawBoard();
    } else { selected=null; drawBoard(); }
  }
});

// Replay feature
replayBtn.addEventListener('click',()=>{
  let replayBoard=[
    ['♜','♞','♝','♛','♚','♝','♞','♜'],
    ['♟','♟','♟','♟','♟','♟','♟','♟'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['♙','♙','♙','♙','♙','♙','♙','♙'],
    ['♖','♘','♗','♕','♔','♗','♘','♖']
  ];
  drawBoard([]);
  let i=0;
  const interval=setInterval(()=>{
    if(i>=moveHistory.length){clearInterval(interval); return;}
    const move=moveHistory[i];
    replayBoard[move.to.row][move.to.col]=move.from.piece;
    replayBoard[move.from.row][move.from.col]='';
    board=replayBoard.map(r=>[...r]);
    drawBoard();
    i++;
  },500);
});
</script>
</body>
</html>
