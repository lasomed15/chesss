<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Full Chess Game with Replay</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: sans-serif;
    background-color: #eee;
  }
  h1 { margin-top: 20px; }
  #chessboard {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 2px solid #333;
    margin-top: 20px;
  }
  .square {
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 36px;
    cursor: pointer;
  }
  .square.black { background-color: #769656; }
  .square.white { background-color: #eeeed2; }
  .selected { border: 3px solid red !important; }
  .highlight { border: 3px solid yellow !important; }
  button { margin-top: 10px; padding: 10px 20px; font-size: 16px; }
  input[type=range] { margin-top: 10px; }
</style>
</head>
<body>
<h1>Chess Game</h1>
<div id="chessboard"></div>
<p id="status"></p>
<button id="replayBtn">Replay Game</button>
<label>Replay Speed: <span id="speedVal">500ms</span></label>
<input type="range" id="speedSlider" min="100" max="2000" step="100" value="500">

<script>
const chessboard = document.getElementById('chessboard');
const status = document.getElementById('status');
const replayBtn = document.getElementById('replayBtn');
const speedSlider = document.getElementById('speedSlider');
const speedVal = document.getElementById('speedVal');

let board = [
  ['♜','♞','♝','♛','♚','♝','♞','♜'],
  ['♟','♟','♟','♟','♟','♟','♟','♟'],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['♙','♙','♙','♙','♙','♙','♙','♙'],
  ['♖','♘','♗','♕','♔','♗','♘','♖']
];

let turn = 'white';
let selected = null;
let moveHistory = []; // store moves for replay
let replaySpeed = parseInt(speedSlider.value);

speedSlider.addEventListener('input', ()=>{
  replaySpeed = parseInt(speedSlider.value);
  speedVal.textContent = replaySpeed+'ms';
});

// Utility
function isWhite(piece){ return ['♙','♖','♘','♗','♕','♔'].includes(piece);}
function isBlack(piece){ return ['♟','♜','♞','♝','♛','♚'].includes(piece);}
function isEmpty(row,col){ return board[row][col] === '';}
function inBounds(row,col){ return row>=0 && row<8 && col>=0 && col<8;}

// Draw board
function drawBoard(highlightSquares=[], highlightMove=null){
  chessboard.innerHTML='';
  for(let row=0;row<8;row++){
    for(let col=0;col<8;col++){
      const square=document.createElement('div');
      square.classList.add('square', (row+col)%2===0?'white':'black');
      square.dataset.row=row;
      square.dataset.col=col;
      square.textContent=board[row][col];
      if(selected && selected.row===row && selected.col===col) square.classList.add('selected');
      if(highlightSquares.some(sq=>sq.row===row && sq.col===col)) square.style.border='3px solid yellow';
      if(highlightMove && ((highlightMove.from.row===row && highlightMove.from.col===col) || 
                           (highlightMove.to.row===row && highlightMove.to.col===col))) square.classList.add('highlight');
      chessboard.appendChild(square);
    }
  }
  status.textContent=`${turn.charAt(0).toUpperCase()+turn.slice(1)}'s turn`;
}

// Legal moves for all pieces
function getLegalMoves(row,col){
  const piece=board[row][col]; const moves=[];
  if(piece==='') return moves;
  const color=isWhite(piece)?'white':'black';
  const enemy=color==='white'?isBlack:isWhite;

  // Pawn
  if(piece==='♙'){
    if(inBounds(row-1,col)&&isEmpty(row-1,col)) moves.push({row:row-1,col});
    if(row===6&&isEmpty(row-1,col)&&isEmpty(row-2,col)) moves.push({row:row-2,col});
    if(inBounds(row-1,col-1)&&enemy(board[row-1][col-1])) moves.push({row:row-1,col:col-1});
    if(inBounds(row-1,col+1)&&enemy(board[row-1][col+1])) moves.push({row:row-1,col:col+1});
  }
  if(piece==='♟'){
    if(inBounds(row+1,col)&&isEmpty(row+1,col)) moves.push({row:row+1,col});
    if(row===1&&isEmpty(row+1,col)&&isEmpty(row+2,col)) moves.push({row:row+2,col});
    if(inBounds(row+1,col-1)&&enemy(board[row+1][col-1])) moves.push({row:row+1,col:col-1});
    if(inBounds(row+1,col+1)&&enemy(board[row+1][col+1])) moves.push({row:row+1,col:col+1});
  }

  // Knight
  if(piece==='♘'||piece==='♞'){
    const deltas=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    deltas.forEach(d=>{ const r=row+d[0],c=col+d[1]; if(inBounds(r,c)&&(!board[r][c]||enemy(board[r][c]))) moves.push({row:r,col:c}); });
  }

  // Rook
  if(piece==='♖'||piece==='♜'){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    dirs.forEach(d=>{
      let r=row+d[0],c=col+d[1];
      while(inBounds(r,c)&&(isEmpty(r,c)||enemy(board[r][c]))){ moves.push({row:r,col:c}); if(!isEmpty(r,c)) break; r+=d[0]; c+=d[1];}
    });
  }

  // Bishop
  if(piece==='♗'||piece==='♝'){
    const dirs=[[1,1],[1,-1],[-1,1],[-1,-1]];
    dirs.forEach(d=>{
      let r=row+d[0],c=col+d[1];
      while(inBounds(r,c)&&(isEmpty(r,c)||enemy(board[r][c]))){ moves.push({row:r,col:c}); if(!isEmpty(r,c)) break; r+=d[0]; c+=d[1];}
    });
  }

  // Queen
  if(piece==='♕'||piece==='♛'){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    dirs.forEach(d=>{
      let r=row+d[0],c=col+d[1];
      while(inBounds(r,c)&&(isEmpty(r,c)||enemy(board[r][c]))){ moves.push({row:r,col:c}); if(!isEmpty(r,c)) break; r+=d[0]; c+=d[1];}
    });
  }

  // King
  if(piece==='♔'||piece==='♚'){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    dirs.forEach(d=>{ const r=row+d[0],c=col+d[1]; if(inBounds(r,c)&&(!board[r][c]||enemy(board[r][c]))) moves.push({row:r,col:c}); });
  }
  return moves;
}

// Check and Checkmate
function inCheck(color){
  let kingPos;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){ if((color==='white'&&board[r][c]==='♔')||(color==='black'&&board[r][c]==='♚')) kingPos={row:r,col:c}; }
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const piece=board[r][c];
    if(piece && ((color==='white'&&isBlack(piece))||(color==='black'&&isWhite(piece)))){
      const moves=getLegalMoves(r,c);
      if(moves.some(m=>m.row===kingPos.row&&m.col===kingPos.col)) return true;
    }
  }
  return false;
}

function checkMate(color){
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const piece=board[r][c];
    if(piece && ((color==='white'&&isWhite(piece))||(color==='black'&&isBlack(piece)))){
      const moves=getLegalMoves(r,c);
      for(const m of moves){
        const backup=board[m.row][m.col];
        board[m.row][m.col]=piece; board[r][c]='';
        if(!inCheck(color)){ board[r][c]=piece; board[m.row][m.col]=backup; return false; }
        board[r][c]=piece; board[m.row][m.col]=backup;
      }
    }
  }
  return true;
}

// Click handling
chessboard.addEventListener('click',(e)=>{
  const square=e.target; if(!square.classList.contains('square')) return;
  const row=parseInt(square.dataset.row); const col=parseInt(square.dataset.col);
  const piece=board[row][col];
  if(!selected){
    if(piece && ((turn==='white'&&isWhite(piece))||(turn==='black'&&isBlack(piece)))){ selected={row,col}; drawBoard(getLegalMoves(row,col)); }
  } else {
    const moves=getLegalMoves(selected.row,selected.col);
    if(moves.some(m=>m.row===row && m.col===col)){
      const movingPiece=board[selected.row][selected.col];
      moveHistory.push({from:{row:selected.row,col:selected.col,piece:movingPiece},to:{row,col,piece:board[row][col]},turn});
      board[row][col]=movingPiece; board[selected.row][selected.col]='';
      if(movingPiece==='♙' && row===0) board[row][col]='♕';
      if(movingPiece==='♟' && row===7) board[row][col]='♛';
      const enemy=turn==='white'?'black':'white';
      if(inCheck(enemy)){ if(checkMate(enemy)) alert(`Checkmate! ${turn.charAt(0).toUpperCase()+turn.slice(1)} wins!`); else alert(`${enemy.charAt(0).toUpperCase()+enemy.slice(1)} is in check!`); }
      turn=enemy; selected=null; drawBoard();
    } else { selected=null; drawBoard(); }
  }
});

// Replay with highlights
replayBtn.addEventListener('click',()=>{
  let replayBoard=[
    ['♜','♞','♝','♛','♚','♝','♞','♜'],
    ['♟','♟','♟','♟','♟','♟','♟','♟'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['♙','♙','♙','♙','♙','♙','♙','♙'],
    ['♖','♘','♗','♕','♔','♗','♘','♖']
  ];
  let i=0;
  const interval=setInterval(()=>{
    if(i>=moveHistory.length){ clearInterval(interval); board=replayBoard.map(r=>[...r]); drawBoard(); return; }
    const move=moveHistory[i];
    replayBoard[move.to.row][move.to.col]=move.from.piece;
    replayBoard[move.from.row][move.from.col]='';
    board=replayBoard.map(r=>[...r]);
    drawBoard([], move);
    i++;
  }, replaySpeed);
});

drawBoard();
</script>
</body>
</html>
