<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chess Game with Smooth Replay</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: sans-serif;
    background-color: #eee;
  }
  h1 { margin-top: 20px; }
  #chessboard {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 2px solid #333;
    margin-top: 20px;
  }
  .square {
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 36px;
    cursor: pointer;
  }
  .square.black { background-color: #769656; }
  .square.white { background-color: #eeeed2; }
  .selected { border: 3px solid red !important; }
  .highlight { border: 3px solid yellow !important; }
  button { margin-top: 10px; padding: 10px 20px; font-size: 16px; }
  input[type=range] { margin-top: 10px; }
</style>
</head>
<body>
<h1>Chess Game</h1>
<div id="chessboard"></div>
<p id="status"></p>
<button id="replayBtn">Replay Game</button>
<label>Replay Speed: <span id="speedVal">500ms</span></label>
<input type="range" id="speedSlider" min="100" max="2000" step="100" value="500">

<script>
const chessboard = document.getElementById('chessboard');
const status = document.getElementById('status');
const replayBtn = document.getElementById('replayBtn');
const speedSlider = document.getElementById('speedSlider');
const speedVal = document.getElementById('speedVal');

let board = [
  ['♜','♞','♝','♛','♚','♝','♞','♜'],
  ['♟','♟','♟','♟','♟','♟','♟','♟'],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['♙','♙','♙','♙','♙','♙','♙','♙'],
  ['♖','♘','♗','♕','♔','♗','♘','♖']
];

let turn = 'white';
let selected = null;
let moveHistory = []; // store moves for replay
let replaySpeed = parseInt(speedSlider.value);

speedSlider.addEventListener('input', ()=>{
  replaySpeed = parseInt(speedSlider.value);
  speedVal.textContent = replaySpeed+'ms';
});

// Utility functions
function isWhite(piece) { return ['♙','♖','♘','♗','♕','♔'].includes(piece); }
function isBlack(piece) { return ['♟','♜','♞','♝','♛','♚'].includes(piece); }
function isEmpty(row, col) { return board[row][col] === ''; }
function inBounds(row, col) { return row >= 0 && row < 8 && col >= 0 && col < 8; }

function drawBoard(highlightSquares=[], highlightMove=null) {
  chessboard.innerHTML = '';
  for(let row=0; row<8; row++) {
    for(let col=0; col<8; col++) {
      const square = document.createElement('div');
      square.classList.add('square', (row+col)%2===0?'white':'black');
      square.dataset.row=row;
      square.dataset.col=col;
      square.textContent = board[row][col];

      if(selected && selected.row===row && selected.col===col) square.classList.add('selected');
      if(highlightSquares.some(sq=>sq.row===row && sq.col===col)) square.style.border='3px solid yellow';
      if(highlightMove && ((highlightMove.from.row===row && highlightMove.from.col===col) || 
                           (highlightMove.to.row===row && highlightMove.to.col===col))) square.classList.add('highlight');

      chessboard.appendChild(square);
    }
  }
  status.textContent = `${turn.charAt(0).toUpperCase()+turn.slice(1)}'s turn`;
}

// Get legal moves (same as before, omitted for brevity in snippet)
function getLegalMoves(row,col){ /*...use previous code...*/ return []; } 
// For brevity here, just reuse the previous full legal move function

// Check/inCheck/CheckMate omitted for brevity (reuse previous code)

// Click handling (same as before)
chessboard.addEventListener('click',(e)=>{
  const square=e.target; if(!square.classList.contains('square')) return;
  const row=parseInt(square.dataset.row);
  const col=parseInt(square.dataset.col);
  const piece=board[row][col];

  if(!selected){
    if(piece && ((turn==='white'&&isWhite(piece))||(turn==='black'&&isBlack(piece)))){
      selected={row,col};
      drawBoard(getLegalMoves(row,col));
    }
  } else {
    const moves=getLegalMoves(selected.row,selected.col);
    if(moves.some(m=>m.row===row && m.col===col)){
      const movingPiece=board[selected.row][selected.col];
      moveHistory.push({from:{row:selected.row,col:selected.col,piece:movingPiece},to:{row,col,piece:board[row][col]},turn});
      board[row][col]=movingPiece; board[selected.row][selected.col]='';
      // Pawn promotion
      if(movingPiece==='♙' && row===0) board[row][col]='♕';
      if(movingPiece==='♟' && row===7) board[row][col]='♛';
      const enemy=turn==='white'?'black':'white';
      // Check/checkmate alerts here if desired
      turn=enemy; selected=null; drawBoard();
    } else { selected=null; drawBoard(); }
  }
});

// Replay feature
replayBtn.addEventListener('click', ()=>{
  let replayBoard=[
    ['♜','♞','♝','♛','♚','♝','♞','♜'],
    ['♟','♟','♟','♟','♟','♟','♟','♟'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['♙','♙','♙','♙','♙','♙','♙','♙'],
    ['♖','♘','♗','♕','♔','♗','♘','♖']
  ];
  let i=0;
  const interval=setInterval(()=>{
    if(i>=moveHistory.length){clearInterval(interval); board=replayBoard.map(r=>[...r]); drawBoard(); return;}
    const move=moveHistory[i];
    replayBoard[move.to.row][move.to.col]=move.from.piece;
    replayBoard[move.from.row][move.from.col]='';
    board=replayBoard.map(r=>[...r]);
    drawBoard([], move); // highlight move
    i++;
  }, replaySpeed);
});

drawBoard();
</script>
</body>
</html>
